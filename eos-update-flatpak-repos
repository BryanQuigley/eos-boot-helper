#!/usr/bin/python3
#
# eos-update-flatpak-repos: adds standard flatpak repos, removes legacy remotes
# and runtimes, and migrates installed flatpaks between origins
#
# Copyright (C) 2017 Endless Mobile, Inc.
# Authors:
#  Mario Sanchez Prada <mario@endlessm.com>
#  Philip Chimento <philip@endlessm.com>
#  Robert McQueen <rob@endlessm.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import argparse
import fnmatch
import glob
import logging
import os
import shutil
import subprocess

from systemd import journal

import gi
gi.require_version('Flatpak', '1.0')
gi.require_version('OSTree', '1.0')
from gi.repository import Flatpak, Gio, GLib, OSTree


def _flatpak_inst_get_remote(inst, name):
    try:
        remote = inst.get_remote_by_name(name)
    except GLib.Error:
        remote = None

    return remote


FLATPAK_REPO_DIR = os.getenv('EOS_FLATPAK_REPO_DIR',
                             '/usr/share/eos-boot-helper/flatpak-repos')


def _add_flatpak_repos():
    insts = Flatpak.get_system_installations()
    inst = insts[0]

    for f in os.listdir(FLATPAK_REPO_DIR):
        if not f.endswith('.flatpakrepo'):
            continue

        name = f[:-12]

        repo_file = os.path.join(FLATPAK_REPO_DIR, f)

        if not os.path.isfile(repo_file):
            continue

        remote = _flatpak_inst_get_remote(inst, name)

        if remote:
            logging.debug("Remote {} already configured in {}"
                          .format(name, inst.get_path().get_path()))
            continue

        logging.info("Adding remote {} to {} from {}"
                     .format(name, inst.get_path().get_path(), repo_file))

        subprocess.check_call(['flatpak', 'remote-add', '--system',
                               '--from', name, repo_file])


# list of ostree refs
OSTREE_REFS_TO_REMOVE = [
    # remove eos3.3 refs leaked by eos-updater checkpoint bug (T23410)
    'eos:os/eos/amd64/eos3',
    'eos:os/eos/ec100/eos3',
    'eos:os/eos/nexthw/eos3'

    # remove eos2 ref left behind after eos-upgrade-eos2-to-eos3 (T23443)
    'eos:eos2/ec100',
    'eos:eos2/i386',

    # remove "initial factory commit" ref from pre-2.3.1 (T23443)
    'local:factory',
]


def _remove_ostree_refs():
    try:
        repo = OSTree.Repo.new_default()
        repo.open()
        _, ostree_refs = repo.list_refs() # dictionary of ref -> commit
        for ref in OSTREE_REFS_TO_REMOVE:
            if ref in ostree_refs:
                logging.info('Deleting leaked OSTree ref {}'.format(ref))
                repo.set_ref_immediate(ref.split(':')[0], ref.split(':')[1],
                                       None)
    except Exception:
        logging.exception('Failure deleting leaked OSTree refs')


# list of remote names
REMOTES_TO_REMOVE = [
]


def _remove_remotes():
    insts = Flatpak.get_system_installations()
    inst = insts[0]

    for name in REMOTES_TO_REMOVE:
        if _flatpak_inst_get_remote(inst, name):
            logging.info("Removing remote {} from {}"
                         .format(name, inst.get_path().get_path()))

            subprocess.check_call(['flatpak', 'remote-delete',
                                   '--system', '--force', name])


# dict of remote -> list of runtimes
RUNTIMES_TO_REMOVE = {
}


def _remove_runtimes():
    insts = Flatpak.get_system_installations()
    inst = insts[0]

    for ref in inst.list_installed_refs_by_kind(Flatpak.RefKind.RUNTIME):
        origin = ref.get_origin()
        if ref.get_origin() not in RUNTIMES_TO_REMOVE:
            continue

        name = ref.get_name()
        if name not in RUNTIMES_TO_REMOVE[origin]:
            continue

        refspec = '{}/{}/{}'.format(name, ref.get_arch(), ref.get_branch())
        logging.info("Removing runtime {} from {}"
                     .format(refspec, inst.get_path().get_path()))
        subprocess.check_call(['flatpak', 'uninstall', '--system',
                               '--runtime', refspec])


def _update_deploy_file_with_origin(deploy_file_path, new_origin_name):
    _update_deploy_file(deploy_file_path, 0, new_origin_name)


def _update_deploy_file(deploy_file_path, idx, new_val):
    logging.debug("Reading data from the deploy file at {}..."
                  .format(deploy_file_path))

    src_file_contents = None
    with open(deploy_file_path, 'rb') as f:
        src_file_contents = GLib.Bytes.new(f.read())

    # We need to read the GVariant in the deploy file and generate a
    # new one with all the same content but the right remote set.
    variant_type = GLib.VariantType.new('(ssasta{sv})')
    orig_variant = GLib.Variant.new_from_bytes(variant_type,
                                               src_file_contents, False)
    logging.debug("Original variant: {}".format(str(orig_variant)))

    cur_val = orig_variant[idx]
    if cur_val == new_val or (isinstance(cur_val, list) and
                              isinstance(new_val, list) and
                              set(cur_val) == set(new_val)):
        logging.info('Nothing to do, {}[{}] already set to: {}'
                     .format(deploy_file_path, idx, new_val))
        return

    builder = GLib.VariantBuilder.new(variant_type)
    for i, val in enumerate(orig_variant):
        child = orig_variant.get_child_value(i)
        if i == idx:
            builder.add_value(GLib.Variant(child.get_type_string(), new_val))
        else:
            builder.add_value(child)

    new_variant = builder.end()
    logging.debug("New variant: {}".format(str(new_variant)))

    # Replace the original deploy file with the new GVariant
    logging.info("Writing new deploy file for {}, setting [{}] to: {}"
                 .format(deploy_file_path, idx, new_val))
    GLib.file_set_contents(deploy_file_path,
                           new_variant.get_data_as_bytes().get_data())


FLATPAKS_TO_MIGRATE = [
    # migrate EknServices from old eos-apps remote to eos-sdk (T17863)
    {
        'name': 'com.endlessm.EknServices',
        'kind': Flatpak.RefKind.APP,
        'old-origin': 'eos-apps',
        'new-origin': 'eos-sdk'
    },
    # fix up image-builder bug where com.endlessm.apps.* runtimes were
    # mistakenly installed with eos-runtimes origin (T18366)
    {
        'name': 'com.endlessm.apps.Platform',
        'kind': Flatpak.RefKind.RUNTIME,
        'old-origin': 'eos-runtimes',
        'new-origin': 'eos-sdk'
    },
    {
        'name': 'com.endlessm.apps.Sdk',
        'kind': Flatpak.RefKind.RUNTIME,
        'old-origin': 'eos-runtimes',
        'new-origin': 'eos-sdk'
    },
    # migrate Steam from eos-apps to flathub (T20322)
    {
        'name': 'com.valvesoftware.Steam',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate org.gnome.* from gnome-apps to flathub (T19898)
    {
        'prefix': 'org.gnome.',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'stable',
        'old-origin': 'gnome-apps',
        'new-origin': 'flathub'
    },
    # migrate Teeworlds and MegaGlest from eos-apps to flathub (T20411)
    {
        'name': 'com.teeworlds.Teeworlds',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.megaglest.MegaGlest',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Atom from eos-apps to flathub (T20301)
    {
        'name': 'io.atom.Atom',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate gnome 3.2[46] and freedesktop 1.6 runtimes to flathub (T20443)
    {
        'prefix': 'org.freedesktop.',
        'kind': Flatpak.RefKind.RUNTIME,
        'old-branch': '1.6',
        'old-origin': 'gnome',
        'new-origin': 'flathub'
    },
    {
        'prefix': 'org.gnome.',
        'kind': Flatpak.RefKind.RUNTIME,
        'old-branch': '3.24',
        'old-origin': 'gnome',
        'new-origin': 'flathub'
    },
    {
        'prefix': 'org.gnome.',
        'kind': Flatpak.RefKind.RUNTIME,
        'old-branch': '3.26',
        'old-origin': 'gnome',
        'new-origin': 'flathub'
    },
    # migrate eos-apps to flathub where the app ID is the same (T20724)
    {
        'name': 'com.google.AndroidStudio',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'com.slack.Slack',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'com.spotify.Client',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'com.transmissionbt.Transmission',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'net.minetest.Minetest',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.freeciv.Freeciv',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.gnome.Builder',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.gnome.Genius',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.gnome.Gnote',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.inkscape.Inkscape',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.pitivi.Pitivi',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.tuxpaint.Tuxpaint',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.videolan.VLC',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.wesnoth.Wesnoth',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Visual Studio Code OSS from eos-apps to flathub (T20306)
    {
        'name': 'com.visualstudio.code.oss',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Sublime Text from eos-apps to flathub (T22875)
    {
        'name': 'com.sublimetext.three',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Photo Editor from eos-apps to flathub (T21891)
    {
        'name': 'com.endlessm.photos',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Dropbox from eos-apps to flathub (T23174)
    {
        'name': 'com.dropbox.Client',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Stellarium from eos-apps to flathub (T23681)
    {
        'name': 'org.stellarium.Stellarium',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    }
]


def _filter_refs(refs, name=None, prefix=None, kind=None, arch=None,
                 branch=None, origin=None):
    ret = []
    for ref in refs:
        if kind and kind != ref.get_kind():
            continue
        if name and name != ref.get_name():
            continue
        if prefix and not ref.get_name().startswith(prefix):
            continue
        if arch and arch != ref.get_arch():
            continue
        if branch and branch != ref.get_branch():
            continue
        if origin and origin != ref.get_origin():
            continue
        ret.append(ref)
    return ret


def _filter_ostree_refs(refs, origin, kind, name='*', prefix=None, arch='*',
                        branch='*'):
    assert origin
    assert kind.value_nick in {'app', 'runtime'}

    if prefix:
        name = '{}*'.format(prefix)

    pattern = '{}:{}/{}/{}/{}'.format(origin, kind.value_nick, name, arch, branch)

    return fnmatch.filter(refs, pattern)


def _replace_in_file(path, old, new):
    _, data = GLib.file_get_contents(path)
    assert data
    GLib.file_set_contents(path, data.replace(old.encode('utf-8'),
                                              new.encode('utf-8')))


def _update_branch(ref, new_branch, refs):
    kind = ref.get_kind()
    name = ref.get_name()
    arch = ref.get_arch()
    branch = ref.get_branch()
    deploy_dir = ref.get_deploy_dir()

    clashing_refs = _filter_refs(refs, name=name, kind=kind,
                                 arch=arch, branch=new_branch)
    if len(clashing_refs) > 0:
        logging.warning('Not migrating {}/{}/{}, new branch {} already exists'
                        .format(name, arch, branch, new_branch))
        raise FileExistsError

    logging.info('Migrating {}/{}/{} to new branch {}'
                 .format(name, arch, branch, new_branch))

    # .../${kind}/${name}/${arch}/${branch} , ${ref}-${subpaths}
    old_branch_dir, ref_dir = os.path.split(deploy_dir)

    # .../${kind}/${name}/${arch}
    arch_dir = os.path.dirname(old_branch_dir)

    # .../${kind}/${name}
    name_dir = os.path.dirname(arch_dir)
    current = os.path.join(name_dir, 'current')
    current_tmp = current + '.tmp'

    # .../${kind}/${name}/${arch}/${new_branch}
    new_branch_dir = os.path.join(arch_dir, new_branch)

    # .../${kind}/${name}/${arch}/${new_branch}/${ref}-${subpaths}
    new_deploy_dir = os.path.join(new_branch_dir, ref_dir)

    try:
        os.mkdir(new_branch_dir, mode=0o755)
        subprocess.check_call(['cp', '-al', deploy_dir, new_deploy_dir])
        os.symlink(ref_dir, os.path.join(new_branch_dir, 'active'))
        if kind == Flatpak.RefKind.APP:
            # update current symlink (specific to apps - runtimes
            # always have a specified branch)
            os.symlink('{}/{}'.format(arch, new_branch), current_tmp)
            os.rename(current_tmp, current)

            # update Exec= line in exported .desktop and .service files
            old_exec = '/flatpak run --branch={} --arch={}'.format(branch,
                                                                   arch)
            new_exec = '/flatpak run --branch={} --arch={}'.format(new_branch,
                                                                   arch)

            for path in glob.glob(os.path.join(new_deploy_dir,
                                  'export/share/applications/*.desktop')):
                logging.debug('Updating branch in {}'.format(path))
                _replace_in_file(path, old_exec, new_exec)

            for path in glob.glob(os.path.join(new_deploy_dir,
                                  'export/share/dbus-1/services/*.service')):
                logging.debug('Updating branch in {}'.format(path))
                _replace_in_file(path, old_exec, new_exec)

    except Exception:
        shutil.rmtree(new_branch_dir, ignore_errors=True)
        if os.path.exists(current_tmp):
            os.unlink(current_tmp)
        raise

    # this is unsafe whilst flatpaks are running
    # however: this is a startup job
    shutil.rmtree(old_branch_dir, ignore_errors=True)


def _refresh_ref(inst, kind, name, arch, branch):
    inst.drop_caches()
    return inst.get_installed_ref(kind, name, arch, branch)


def _migrate_installed_flatpaks():
    insts = Flatpak.get_system_installations()
    inst = insts[0]
    refs = inst.list_installed_refs()

    # we need to also operate directly on the ostree refs that shadow each
    # flatpak so we don't leave behind local refs to the old origin and branch.
    repo = OSTree.Repo.new(inst.get_path().get_child('repo'))
    repo.open()
    _, ostree_refs = repo.list_refs() # dictionary of ref -> commit

    for migrate in FLATPAKS_TO_MIGRATE:
        kind = migrate['kind']
        old_origin = migrate['old-origin']

        name = migrate.get('name')
        prefix = migrate.get('prefix')
        assert name or prefix

        old_branch = migrate.get('old-branch')

        # we build what should be the same list twice - from the flatpak
        # perspective by examining the installation and deployed apps, and from
        # the ostree perspective by examining the refs in the repo. ordinarily
        # we would only see them differ due to a bug in previous versions of
        # this script where the refs were not renamed during a migration.
        # everything in the matching_ostree_refs list will be copied to its
        # new name if we change (or previously changed) the branch or origin,
        # and then deleted after the deployed apps are updated. (T22763)
        matching_refs = _filter_refs(refs, name=name, prefix=prefix, kind=kind,
                                     branch=old_branch, origin=old_origin)
        matching_ostree_refs = _filter_ostree_refs(ostree_refs.keys(),
                                                   old_origin, kind,
                                                   name=name, prefix=prefix,
                                                   branch=old_branch)

        # also search for name.* runtimes to migrate to catch extensions
        # unless we are already searching runtimes by prefix - in this case
        # we will already have found the matching extensions
        if name or kind == Flatpak.RefKind.APP:
            if not prefix:
                prefix = name + '.'
            matching_refs += _filter_refs(refs, prefix=prefix,
                                          kind=Flatpak.RefKind.RUNTIME,
                                          branch=old_branch, origin=old_origin)

            matching_ostree_refs += _filter_ostree_refs(ostree_refs.keys(),
                                                        old_origin,
                                                        Flatpak.RefKind.RUNTIME,
                                                        prefix=prefix,
                                                        branch=old_branch)

        if len(matching_refs) == 0:
            if name:
                logging.debug('Found no matches to migrate for {} {}'
                              .format(kind.value_nick, name))
            else:
                logging.debug('Found no matches to migrate for {} {}*'
                              .format(kind.value_nick, prefix))

        for ref in matching_refs:
            name = ref.get_name()
            arch = ref.get_arch()
            branch = ref.get_branch()
            logging.info('Found {}/{}/{} to migrate'
                         .format(name, arch, branch))

            old_ostree_ref = '{}:{}'.format(ref.get_origin(), ref.format_ref())

            try:
                new_branch = migrate.get('new-branch')
                if new_branch:
                    _update_branch(ref, new_branch, refs)
                    branch = new_branch
                    ref = _refresh_ref(inst, kind, name, arch, branch)

                deploy_dir = ref.get_deploy_dir()
                deploy = os.path.join(deploy_dir, 'deploy')

                new_origin = migrate.get('new-origin')
                if new_origin:
                    _update_deploy_file_with_origin(deploy, new_origin)
                    origin = new_origin
                    ref = _refresh_ref(inst, kind, name, arch, branch)

                new_ostree_ref = '{}:{}'.format(ref.get_origin(), ref.format_ref())

                # in the case the ref has not changed, we should remove it from
                # the list of old refs so it will not be deleted
                if new_ostree_ref == old_ostree_ref:
                    logging.debug('OSTree ref {} unchanged'
                                  .format(old_ostree_ref))
                    matching_ostree_refs.remove(old_ostree_ref)
                    continue

                # when the branch or origin has changed, we copy the old ref to
                # the new one, pointing at the same commit
                if old_ostree_ref in ostree_refs and \
                   not new_ostree_ref in ostree_refs:
                    logging.info('Copying OSTree ref {} [{}] to {}'
                                 .format(old_ostree_ref,
                                         ostree_refs[old_ostree_ref],
                                         new_ostree_ref))
                    repo.set_ref_immediate(ref.get_origin(), ref.format_ref(),
                                           ostree_refs[old_ostree_ref])
                    ostree_refs[new_ostree_ref] = ostree_refs[old_ostree_ref]

            except Exception:
                logging.exception('Failure applying migration to {}'
                                  .format(name))
                continue

        # any refs we copied, along with any matches for apps we migrated
        # in the past, should be deleted.
        for old_ostree_ref in matching_ostree_refs:
            try:
                logging.info('Deleting old/stale OSTree ref {} [{}]'
                             .format(old_ostree_ref,
                                     ostree_refs[old_ostree_ref]))
                repo.set_ref_immediate(old_ostree_ref.split(':')[0],
                                       old_ostree_ref.split(':')[1],
                                       None)
            except Exception:
                logging.exception('Failure deleting ref {}'
                                  .format(old_ostree_ref))
                continue


if __name__ == '__main__':
    # Send logging messages both to the console and the journal
    logging.basicConfig(level=logging.INFO)
    logging.root.addHandler(journal.JournalHandler())

    parser = argparse.ArgumentParser()
    parser.add_argument('--debug', '-d', dest='debug', action='store_true')
    parsed_args, otherargs = parser.parse_known_args()

    if parsed_args.debug:
        logging.root.setLevel(logging.DEBUG)

    # ensure default remotes exist, such as eos-sdk and flathub
    _add_flatpak_repos()

    # remove any unused refs, remotes and runtimes
    _remove_ostree_refs()
    _remove_remotes()
    _remove_runtimes()

    # move apps and runtimes between branches and origins as specified above
    _migrate_installed_flatpaks()
