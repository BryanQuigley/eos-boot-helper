#!/usr/bin/python3
# Copyright (C) 2016-2018 Endless Mobile, Inc.
# Licensed under the GPLv2
import argparse
import json
import subprocess


class UnexpectedLayoutError(Exception):
    pass


ESP_GUID = "C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
BIOS_BOOT_GUID = "21686148-6449-6E6F-744E-656564454649"
DPS_ROOT_GUID = "4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709"


def check_partitions(partitions, guids):
    if len(partitions) != len(guids):
        raise UnexpectedLayoutError(
            'Expected {} partitions'.format(len(guids)))

    for i, (partition, guid) in enumerate(zip(partitions, guids), 1):
        if partition['type'] != guid:
            raise UnexpectedLayoutError(
                'Expected partition {} to have type {}'.format(i, guid))

    return partitions


def munge_sfdisk_output(data):
    partitiontable = data['partitiontable']
    partitions = partitiontable['partitions']

    guids = (ESP_GUID, BIOS_BOOT_GUID, DPS_ROOT_GUID)
    esp, bios_boot, root = check_partitions(partitions, guids)

    for partition in partitions:
        del partition['node']
        del partition['uuid']

    # GPT -> DOS
    partitiontable['label'] = 'dos'

    esp['type'] = 'EF'
    # Remove BIOS boot partition (but leave its former contents intact)
    partitions.remove(bios_boot)
    # Set MBR partition type on root partition, and mark as bootable (not strictly
    # true, but our MBR does not care - some BIOSes don't consider a drive to be
    # bootable without it)
    root['type'] = '83'
    root['bootable'] = True
    del root['attrs']


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('root_disk')

    args = parser.parse_args()
    root_disk = args.root_disk

    result = subprocess.run(('sfdisk', '--dump', '--json', args.root_disk),
                            stdout=subprocess.PIPE, check=True)
    data = json.loads(result.stdout)

    try:
        munge_sfdisk_output(data)
    except UnexpectedLayoutError as e:
        sys.stderr.write('Unexpected partition table layout: {}\n',
                         ' '.join(e.args))
        sys.stderr.write('sfdisk output was: {}\n'.format(result.stdout))
        sys.exit(1)

    result = subprocess.run(('sfdisk', '--force', '--no-reread', '--json'

echo "$parts" | sfdisk --force --no-reread "$root_disk"
udevadm settle
partprobe "${root_disk}"
udevadm settle

# Set marker on 4th partition so that the partition gets enlarged to fill the
# disk on first boot
printf "\xdd" | dd of="$root_disk" bs=1 count=1 seek=498 conv=notrunc
udevadm settle

# Remove GPT headers. It's a little tricky to work out where the backup one is
# from sfdisk's output, but we can get it from the primary header:
# https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_table_header_.28LBA_1.29
backup_gpt_offset=$(
  dd if="$root_disk" bs=1 count=8 skip=$(( 512 + 0x20 )) | python3 -c \
    'import sys, struct; print(struct.unpack("<Q", sys.stdin.buffer.read(8))[0])'
)
backup_gpt="$(dd if="$root_disk" bs=512 skip="$backup_gpt_offset" count=1)"
if [ "${backup_gpt::8}" != "EFI PART" ]; then
  echo "$0: couldn't find backup GPT header at ${backup_gpt_offset}" >&2
  exit 1
fi
dd if=/dev/zero of="$root_disk" conv=fsync bs=512 count=1 seek=1
udevadm settle
dd if=/dev/zero of="$root_disk" conv=fsync bs=512 count=1 seek="$backup_gpt_offset"
udevadm settle
