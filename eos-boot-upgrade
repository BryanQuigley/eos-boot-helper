#!/usr/bin/python3 -u

import os
import subprocess
import re
import sys
import json
import shutil
import tempfile
import contextlib
import distutils

class BootUpgradeException(Exception):
    def __init__(self, *args):
        self.msg = ' '.join(map(str, args))

    def __str__(self):
        return str(self.msg)

@contextlib.contextmanager
def TemporaryDirectory():
    d = tempfile.mkdtemp()
    try:
        yield d
    finally:
        shutil.rmtree(d)

@contextlib.contextmanager
def mount(device):
    with TemporaryDirectory() as mount_point:
        subprocess.check_call(['mount', device, mount_point])
        try:
            yield mount_point
        finally:
            subprocess.check_call(['umount', mount_point])

class Cmdline(object):
    def __init__(self):
        self.options = {}
        self.parse()

    def parse(self):
        with open('/proc/cmdline', 'r') as f:
            for option in f.readline().strip().split():
                fields = option.split("=")
                if len(fields) == 1:
                    self.options[fields[0]] = True
                else:
                    self.options[fields[0]] = fields[1]

class Partition(object):
    def __init__(self, part_number, disk, **kwargs):
        self.disk = disk
        self.number = part_number
        for config_name in kwargs:
            setattr(self, config_name, kwargs[config_name])

    @staticmethod
    def parse(config, disk):
        if 'node' not in config:
            raise BootUpgradeException('sfdisk error') 

        part_number = re.match('^.*([0-9]+)$', config['node']).group(1)
        part_config = {
            'device': config['node'],
            'uuid': config.get('uuid'),
            'type': config.get('type')
        }
        return Partition(part_number, disk, **part_config)

class Disk(object):
    def __init__(self, device):
        self.label = None
        self.partitions = {}
        self.device = device

        self._read_partition_table()

    def _read_partition_table(self):
        sfdisk_json = subprocess.check_output(['sfdisk', '--json', self.device]).decode('utf-8');
        disk_config = json.loads(sfdisk_json)

        self.label = disk_config['partitiontable']['label'] or None

        for part_config in disk_config['partitiontable']['partitions']:
            part = Partition.parse(part_config, self)
            self.partitions[part.number] = part

    def get_partition_by_guid(self, guid):
        for part_num, conf in self.partitions.items():
            if conf.type == guid:
                return self.partitions[part_num]
        return None

class BootDisk(Disk):
    def __init__(self):
        super().__init__(self._get_booting_device())

    def _get_booting_device(self):
        root_part_device = subprocess.check_output([
            'systemctl', 'show', '-p', 'What', 'sysroot.mount'
            ]).decode('utf-8').strip()
    
        root_part_device = root_part_device[5:]
        if not root_part_device:
            raise BootUpgradeException('Could not identify root device')

        boot_disk_device = re.sub('(p[0-9]+)$', "", root_part_device)
        if root_part_device == boot_disk_device:
            boot_disk_device = re.sub('([0-9]+)$', "", root_part_device)

        return boot_disk_device

def get_disk():
        disk = BootDisk()
        if disk.label != 'gpt':
            raise BootUpgradeException('GPT not found')
        print('[*] Booting disk: ' + disk.device)
        print('[*] Partition table: ' + disk.label)

        root_partition = disk.get_partition_by_guid('4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709')
        if not root_partition:
            raise BootUpgradeException('root partition not found')
        print('[*] Root partition: ' + root_partition.device)

        return disk

def get_esp(disk):
        esp_partition = disk.get_partition_by_guid('C12A7328-F81F-11D2-BA4B-00A0C93EC93B')
        if not esp_partition:
            raise BootUpgradeException('ESP partition not found')
        if not esp_partition.device.endswith('1'):
            raise BootUpgradeException('ESP is not the first partition')
        print('[*] ESP partition: ' + esp_partition.device)

        return esp_partition

def get_dir_size(dir_path):
    total_size = 0
    for (dirpath, dirnames, filenames) in os.walk(dir_path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            total_size += (os.path.getsize(fp) if os.path.isfile(fp) else 0)
        
    return total_size

def get_partition_free_space(dir_path):
    (total, used, free) = shutil.disk_usage(dir_path);
    return free

def check_esp_space(esp_mount, ostree_boot_efi_path):
    ostree_boot_efi_size = get_dir_size(ostree_boot_efi_path);
    print('[*] New EFI deployment size: {0} bytes'.format(ostree_boot_efi_size))

    esp_free_space = get_partition_free_space(esp_mount);
    print('[*] ESP free space: {0} bytes'.format(esp_free_space))

    return esp_free_space > ostree_boot_efi_size

def do_uefi_upgrade():
    try:
        disk = get_disk();
        esp_partition = get_esp(disk);

        with mount(esp_partition.device) as esp_mount:
            ostree_boot_efi_path = os.path.join(eos_cmdline.options['ostree'], 'boot/efi')
            if not check_esp_space(esp_mount, ostree_boot_efi_path):
                raise BootUpgradeException('Not enough space in the ESP')

            list = distutils.dir_util.copy_tree(ostree_boot_efi_path, 

    except (BootUpgradeException, subprocess.CalledProcessError) as BUException:
        print(BUException)

if __name__ == '__main__':
    eos_cmdline = Cmdline()
    
    if 'endless.image.device' in eos_cmdline.options:
        print('Dual boot detected. Bailing out.')
        sys.exit(0)
    
    if 'ostree' not in eos_cmdline.options:
        print('Not an ostree system?')
        sys.exit(0)
    
    if not os.path.exists('/sys/firmware/efi'):
        print('BIOS upgrade not yet implemented')
        sys.exit(0)

    print('Starting UEFI upgrade...')
    do_uefi_upgrade()

