#!/usr/bin/python3 -u

import contextlib
import distutils.dir_util
import filecmp
import json
import os
import re
import shutil
import sys
import subprocess

class BootUpgradeException(Exception):
    def __init__(self, *args):
        self.msg = ' '.join(map(str, args))

    def __str__(self):
        return str(self.msg)

@contextlib.contextmanager
def mount(device, mount_point):
    subprocess.check_call(['mount', device, mount_point])
    try:
        yield mount_point
    finally:
        subprocess.check_call(['umount', mount_point])

class Cmdline(object):
    def __init__(self):
        self.options = {}
        self.parse()

    def parse(self):
        with open('/proc/cmdline', 'r') as f:
            for option in f.readline().strip().split():
                fields = option.split("=", 1)
                if len(fields) == 1:
                    self.options[fields[0]] = True
                else:
                    self.options[fields[0]] = fields[1]

class Partition(object):
    def __init__(self, part_number, disk, **kwargs):
        self.disk = disk
        self.number = part_number
        for config_name in kwargs:
            setattr(self, config_name, kwargs[config_name])

    @staticmethod
    def parse(config, disk):
        if 'node' not in config:
            raise BootUpgradeException('sfdisk error') 

        part_number = re.match('^.*([0-9]+)$', config['node']).group(1)
        part_config = {
            'device': config['node'],
            'uuid': config.get('uuid'),
            'type': config.get('type')
        }
        return Partition(part_number, disk, **part_config)

class Disk(object):
    def __init__(self, device):
        self.label = None
        self.partitions = {}
        self.device = device

        self._read_partition_table()

    def _read_partition_table(self):
        sfdisk_json = subprocess.check_output(['sfdisk', '--json', self.device]).decode('utf-8');
        disk_config = json.loads(sfdisk_json)

        self.label = disk_config['partitiontable']['label'] or None

        for part_config in disk_config['partitiontable']['partitions']:
            part = Partition.parse(part_config, self)
            self.partitions[part.number] = part

    def get_partition_by_guid(self, guid):
        for part_num, conf in self.partitions.items():
            if conf.type == guid:
                return self.partitions[part_num]
        return None

class BootDisk(Disk):
    def __init__(self):
        super().__init__(self._get_booting_device())

    def _get_booting_device(self):
        root_part_device = subprocess.check_output([
            'systemctl', 'show', '-p', 'What', 'sysroot.mount'
            ]).decode('utf-8').strip()
    
        root_part_device = root_part_device[5:]
        if not root_part_device:
            raise BootUpgradeException('Could not identify root device')

        boot_disk_device = re.sub('(p[0-9]+)$', "", root_part_device)
        if root_part_device == boot_disk_device:
            boot_disk_device = re.sub('([0-9]+)$', "", root_part_device)

        return boot_disk_device

def get_disk():
        disk = BootDisk()
        print('[*] Booting disk: ' + disk.device)

        if disk.label != 'gpt':
            raise BootUpgradeException('[!] Partition table is not GPT')

        root_partition = disk.get_partition_by_guid('4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709')
        if not root_partition:
            raise BootUpgradeException('[!] root partition not found (or wrong GUID)')
        print('[*] Root partition: ' + root_partition.device)

        return disk

def get_esp(disk):
        esp_partition = disk.get_partition_by_guid('C12A7328-F81F-11D2-BA4B-00A0C93EC93B')
        if not esp_partition:
            raise BootUpgradeException('[!] ESP partition not found (or wrong GUID)')
        if not esp_partition.device.endswith('1'):
            raise BootUpgradeException('[!] ESP is not the first partition')
        print('[*] ESP partition: ' + esp_partition.device)

        return esp_partition

def get_dir_size(dir_path):
    total_size = 0
    for (dirpath, dirnames, filenames) in os.walk(dir_path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            total_size += (os.path.getsize(fp) if os.path.isfile(fp) else 0)
        
    return total_size

def get_partition_free_space(dir_path):
    (_, _, free) = shutil.disk_usage(dir_path);
    return free

def check_esp_space(esp_mount, ostree_boot_efi_path):
    ostree_boot_efi_size = get_dir_size(ostree_boot_efi_path);
    esp_free_space = get_partition_free_space(esp_mount);

    return esp_free_space > ostree_boot_efi_size

def _dir_cmp(dcmp):
    if dcmp.diff_files or dcmp.right_only:
        return True
    for sub_dcmp in dcmp.subdirs.values():
        if _dir_cmp(sub_dcmp):
            return True
    return False

def check_for_upgrade(esp_mount, ostree_boot_efi_path):
    dcmp = filecmp.dircmp(esp_mount, ostree_boot_efi_path)
    return _dir_cmp(dcmp)

def do_uefi_upgrade(esp_mount, ostree_boot_efi_path):
    tmp_dest_directory = os.path.join(esp_mount, 'new')

    try:
        distutils.dir_util.copy_tree(ostree_boot_efi_path, tmp_dest_directory)
        upgrade_list = distutils.dir_util.copy_tree(ostree_boot_efi_path, esp_mount)
        os.sync()
    finally:
        distutils.dir_util.remove_tree(tmp_dest_directory)

    print('[*] Updated:')
    print(*upgrade_list, sep='\n')

def start_uefi_upgrade():
    esp_mount = '/boot/efi'
    ostree_boot_efi_path = os.path.join(eos_cmdline.options['ostree'], 'boot/efi')

    try:
        disk = get_disk();
        esp_partition = get_esp(disk);

        if not os.path.isdir(esp_mount):
            raise BootUpgradeException('[!] ESP mountpoint', esp_mount, 'does not exist')

        with mount(esp_partition.device, esp_mount) as esp_mount:
            if not check_for_upgrade(esp_mount, ostree_boot_efi_path):
                print('[*] No UEFI files to upgrade')
                return

            if not check_esp_space(esp_mount, ostree_boot_efi_path):
                raise BootUpgradeException('[!] Not enough space in the ESP')

            do_uefi_upgrade(esp_mount, ostree_boot_efi_path)

    except (BootUpgradeException, subprocess.CalledProcessError) as BUException:
        print(BUException)

def start_conf_upgrade():
    conf_path = '/boot/grub/grub.cfg'
    new_conf_path = '/usr/lib/grub/conf/grub.cfg'

    try:
        if filecmp.cmp(conf_path, new_conf_path):
            print('[*] No configuration file to upgrade')
            return

        shutil.copyfile(new_conf_path, conf_path); 
        os.sync()

        print('[*] Updated:')
        print(conf_path)

    except (BootUpgradeException, FileNotFoundError, OSError) as BUException:
        print(BUException)
    
if __name__ == '__main__':
    eos_cmdline = Cmdline()
    
    if 'endless.image.device' in eos_cmdline.options:
        print('[!] Dual boot detected. Bailing out.')
        sys.exit(0)
    
    if 'ostree' not in eos_cmdline.options:
        print('[!] Not an ostree system?')
        sys.exit(0)
    
    if not os.path.exists('/sys/firmware/efi'):
        print('[!] BIOS upgrade not yet implemented')
        sys.exit(0)

    print('==> Starting UEFI/configuration upgrade...')
    start_uefi_upgrade()
    start_conf_upgrade()
